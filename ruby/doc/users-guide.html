<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">
  <title>Kwery User's Guide</title>
  <meta name="generator" content="kwaser">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <link rel="stylesheet" href="docstyle.css" type="text/css">
 </head>
 <body>

  <blockquote>
   <div class="mainbody">

    <div align="left"><h1>Kwery User's Guide</h1></div>
    <div align="left">
      last update: $Date: $<br>
    </div>

<a name="Preface"></a>
<h2 class="section1">Preface</h2>
<p>Kwery is a pretty database library.
You can use Kwery as database library (like DBI), or as O/R Mapper.
</p>
<ul type="disc">
<li>Kwery is very small and lightweight.
   It is suitable especially for CGI script.
</li>
<li>It is not necessary to define model class.
   If you don't define model class, you can use Hash object instead of model object.
</li>
<li>You can define model class to map tables (optional).
</li>
<li>It is very easy to use Kwery if you already know SQL.
</li>
<li>Currently Kwery supports only MySQL, but it will be easy to support other RDBMS.
</li>
<li>Kwery doesn't have validation functionality currently.
</li>
</ul>
<a name="Table of contents"></a>
<h3 class="section2">Table of contents</h3>
<ul>
  <li><a href="#Preface">Preface</a>
  <ul>
    <li><a href="#Table of contents">Table of contents</a>
    </li>
  </ul>
  </li>
  <li><a href="#Query (without model class)">Query (without model class)</a>
  <ul>
    <li><a href="#create table">create table</a>
    </li>
    <li><a href="#insert into">insert into</a>
    </li>
    <li><a href="#select from">select from</a>
    <ul>
      <li><a href="#get()">get()</a>
      </li>
      <li><a href="#get_all()">get_all()</a>
      </li>
      <li><a href="#select()">select()</a>
      </li>
    </ul>
    </li>
    <li><a href="#update">update</a>
    </li>
    <li><a href="#delete from">delete from</a>
    </li>
  </ul>
  </li>
  <li><a href="#Query (with model class)">Query (with model class)</a>
  <ul>
    <li><a href="#create table">create table</a>
    </li>
    <li><a href="#insert into">insert into</a>
    </li>
    <li><a href="#select from">select from</a>
    <ul>
      <li><a href="#get()">get()</a>
      </li>
      <li><a href="#get_all()">get_all()</a>
      </li>
      <li><a href="#select()">select()</a>
      </li>
    </ul>
    </li>
    <li><a href="#update">update</a>
    </li>
    <li><a href="#delete from">delete from</a>
    </li>
  </ul>
  </li>
  <li><a href="#Relation">Relation</a>
  <ul>
    <li><a href="#N : 1 (belongs to)">N : 1 (belongs to)</a>
    </li>
    <li><a href="#1 : N (has many)">1 : N (has many)</a>
    </li>
    <li><a href="#1 : 1 (has one)">1 : 1 (has one)</a>
    </li>
    <li><a href="#N : M (has many through)">N : M (has many through)</a>
    </li>
  </ul>
  </li>
</ul>
<br>


<br>


<a name="Query (without model class)"></a>
<h2 class="section1">Query (without model class)</h2>
<a name="create table"></a>
<h3 class="section2">create table</h3>
<a name="011_create_tables1.rb"></a>
<div class="program_caption">
create_tables1.rb</div>
<pre class="program"><strong>require 'kwery'</strong>
<strong>require 'kwery/adapters/mysql'</strong>

sql1 = &lt;&lt;END
create table teams (
  id          integer       primary key auto_increment,
  name        varchar(255)  not null unique,
  `desc`      text,
  leader_id   integer       references members(id),
  created_at  timestamp,
  updated_at  timestamp
) engine=InnoDB
END

sql2 = &lt;&lt;END
create table members (
  id          integer       primary key auto_increment,
  name        varchar(255)  not null,
  `desc`      text,
  team_id     integer       not null,
  created_at  timestamp,
  updated_at  timestamp
) engine=InnoDB
END

## create Query object
<strong>conn = Kwery.connect('localhost', 'username', 'password', 'dbname')</strong>
<strong>q = Kwery::Query.new(conn)</strong>
q.output = $stderr     #=&gt; reports SQL to $stderr

## Query#execute() executes any kind of SQL
<strong>q.execute(sql1)</strong>
<strong>q.execute(sql2)</strong>
</pre>
<br>


<a name="insert into"></a>
<h3 class="section2">insert into</h3>
<a name="021_insert_into1.rb"></a>
<div class="program_caption">
insert_into1.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'

conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## insert Array
<strong>q.insert('teams', [nil, 'sos', 'SOS Brigate', nil, :current_timestamp, :current_timestamp])</strong>
<strong>id = q.last_insert_id</strong>  # get sos's id
<strong>q.insert('members', [nil, 'Haruhi', nil, id, :current_timestamp, :current_timestamp])</strong>
<strong>q.insert('members', [nil, 'Mikuru', nil, id, :current_timestamp, :current_timestamp])</strong>
<strong>q.insert('members', [nil, 'Yuki', nil, id, :current_timestamp, :current_timestamp])</strong>

## insert Hash
<strong>q.insert('teams', {:name=&gt;'ryouou', :desc=&gt;'Ryouou Hight-School',</strong>
                    <strong>:created_at=&gt;:current_timestamp, :updated_at=&gt;:current_timestamp})</strong>
<strong>id = q.last_insert_id</strong>  # get ryouou's id
<strong>now = :current_timestamp</strong>
<strong>q.insert('members', {:name=&gt;'Konata', :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert('members', {:name=&gt;'Kagami', :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert('members', {:name=&gt;'Tsukasa', :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert('members', {:name=&gt;'Miyuki', :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
</pre>
<br>


<a name="select from"></a>
<h3 class="section2">select from</h3>
<p>There are several methods for 'select from'.
</p>
<a name="get()"></a>
<h4 class="section3">get()</h4>
<p>Kwery::Query#get() returns a row.
</p>
<a name="031_get1.rb"></a>
<div class="program_caption">
get1.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### get row
<strong>sos = q.get('teams') {|c| c.where(:id, 1)</strong>
          #=&gt; select * from teams where id = 1
p sos     #=&gt; {"id"=&gt;1, "name"=&gt;"sos", "desc"=&gt;"SOS Brigate", "leader_id"=&gt;nil, ... }
<strong>haruhi = q.get('members') {|c| c.where(:name, 'Haruhi')</strong>
          #=&gt; select * from members where name = 'Haruhi'
p haruhi  #=&gt; {"id"=&gt;1, "name="Haruhi", "desc"=&gt;nil, "team_id"=&gt;1, ... }
</pre>
<p>The followings are equivarent each other.
</p>
<ul type="disc">
<li>q.get('members') { q.where(:name, 'Haruhi') }
</li>
<li>q.get('members') { q.where('name', 'Haruhi') }
</li>
<li>q.get('members') { q.where('name = ', 'Haruhi') }
</li>
<li>q.get('members') { q.where('name = %s', ['Haruhi']) }
</li>
<li>q.get('members') { q.where("name = 'Haruhi'") }
</li>
</ul>
<p>You can specify several 'where' conditions.
</p>
<a name="032_get2.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get('members') {|c|
  <strong>c.where(:team_id, sos['id']).where('created_at &gt;', t).where_is_not_null(:desc)</strong>
}
### or
members = q.get('members') {|c|
  c.where(:team_id, sos['id'])
  c.where('created_at &gt;', t)
  c.where_is_not_null(:desc)
}
</pre>
<p><code>Query#get('table', <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#get('table') {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="033_get3.rb"></a>
<pre class="program">### select row with condition
haruhi = q.get('members', :name, 'Haruhi')
### This is equvarent to the following.
#haruhi = q.get('members') {|c| c.where(:name, 'Haruhi') }
</pre>
<br>

<a name="get_all()"></a>
<h4 class="section3">get_all()</h4>
<p>Kwery::Query#get() returns all rows matched to condition.
</p>
<a name="041_get_all1.rb"></a>
<div class="program_caption">
get_all1.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## SOS Brigate
sos = q.get('teams') { q.where(:name, 'sos') }

## get all members of SOS Brigate
<strong>members = q.get_all('members') { q.where(:team_id, sos['id']) }</strong>
            #=&gt; select * from members where team_id = 1
for member in members
  p member  #=&gt; {"id"=&gt;1, "name"=&gt;"Haruhi", "team_id"=&gt;1, ...}
            #=&gt; {"id"=&gt;2, "name"=&gt;"Mikuru", "team_id"=&gt;1, ... }
	    #=&gt; {"id"=&gt;3, "name"=&gt;"Yuki", "team_id"=&gt;1, ... }
end
</pre>
<p>You can specify several 'where' conditions.
</p>
<a name="042_get_all2.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get_all('members') {|c|
  <strong>c.where(:team_id, sos['id']).where('created_at &gt;', t).where_is_not_null(:desc)</strong>
}
### or
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id'])
  c.where('created_at &gt;', t)
  c.where_is_not_null(:desc)
}
</pre>
<p>'order_by', 'group_by', 'having', 'limit' are also available.
</p>
<a name="043_get_all3.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id'])<strong>.order_by(:id).limit(0, 2)</strong>
}
### or
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id'])
  c.order_by(:id)
  c.limit(0, 2)
}
</pre>
<p><code>Query#get_all('table', <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#get_all('table') {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="044_get_all4.rb"></a>
<pre class="program">members = <strong>q.get_all('members', :team_id, ryouou['id'])</strong>
### This is equivarent to the following
#members = q.get_all('members') {|c| c.where(:team_id, ryouou['d']) }
</pre>
<br>

<a name="select()"></a>
<h4 class="section3">select()</h4>
<p>Kwery::Query#select() returns all rows matched to conditions.
It is able to specify select colums by Query#select().
</p>
<a name="051_select_from1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### select only id and name columns
sos = q.get('teams') { q.where(:name, 'sos') }
members = <strong>q.select('members', 'id, name') { q.where(:team_id, sos['id']) }</strong>
p members    #=&gt; [{"name"=&gt;"Haruhi", "id"=&gt;1},
             #    {"name"=&gt;"Mikuru", "id"=&gt;2},
             #    {"name"=&gt;"Yuki", "id"=&gt;3}]
</pre>
<p>It is able to specify class object as which records are get.
</p>
<a name="052_select_form2.rb"></a>
<pre class="program">### specify to get as Array instead of Hash
members = q.select('members', 'id, name', <strong>Array</strong>) { q.where(:team_id, sos['id']) }
p members   #=&gt; [[1, 'Haruhi'], [2, 'Mikuru'], [3, 'Yuki']]
</pre>
<p>If you want to join tables, specify table names in select().
</p>
<a name="053_select_from3.rb"></a>
<pre class="program">records = q.select(<strong>'members, teams'</strong>, '*', Array) {|c|
  <strong>c.where('members.team_id = teams.id')</strong>
  c.where('teams.name =', 'sos')
}
require 'pp'
pp records  #=&gt; [[1, "Haruhi", nil, 1, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
            #     1, "sos", "SOS Brigae", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;],
            #    [2, "Mikuru", nil, 1, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
            #     1, "sos", "SOS Brigate", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;],
            #    [3, "Yuki", nil, 1, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
            #     1, "sos", "SOS Brigate", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;],
</pre>
<p>You can select only a certain table's record when joining.
</p>
<a name="054_select_from4.rb"></a>
<pre class="program">records = q.select('members, teams', <strong>'members.*'</strong>) {|c|
  c.where('members.team_id = teams.id')
  c.where('teams.name =', 'sos')
}
p records  #=&gt; [{"id"=&gt;1, "name"=&gt;"Haruhi", "team_id"=&gt;1, ... },
           #    {"id"=&gt;2, "name"=&gt;"Mikuru", "team_id"=&gt;1, ... },
           #    {"id"=&gt;3, "name"=&gt;"Yuki", "team_id"=&gt;1, ... }]
</pre>
<p>Left outer join is available.
</p>
<a name="055_select_from5.rb"></a>
<pre class="program">records = q.select(<strong>'teams'</strong>, '*', Array) {|c|
  <strong>c.left_outer_join('members', 'leader_id')</strong>
}
p records  #=&gt; [[1, "sos", "SOS Brigate", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
           #    1, "Haruhi", nil, 1, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;],
           #    [2, "ryouou", "Ryouou Hight-School", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
           #    nil, nil, nil, nil, nil, nil]]
</pre>
<p>The following is an example to count members for each teams.
</p>
<a name="056_select_count6.rb"></a>
<pre class="program">records = q.select('teams, members', 'teams.id, count(*) count', Array) {|c|
  c.where('teams.id = members.team_id').group_by('teams.id').order_by('teams.id')
}
      #=&gt; select teams.id, count(*) count from teams, members
      #   where teams.id = members.team_id
      #   group by teams.id
      #   order by teams.id

p records    #=&gt; [[1, 3], [2, 4]]

records = q.select('teams t, members m', 't.id, t.name, count(*) count', Array) {|c|
  c.where('t.id = m.team_id').group_by('t.id, t.name').order_by('t.id')
}
      #=&gt; select t.id, t.name, count(*) count from teams t, members m
      #   where t.id = m.team_id 
      #   group by t.id, t.name 
      #   order by t.id

p records    #=&gt; [[1, "sos", 3], [2, "ryouou", 4]]
</pre>
<br>

<br>


<a name="update"></a>
<h3 class="section2">update</h3>
<p>Query#update() updates data matched to conditions.
</p>
<a name="061_update1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### update column
sos = q.get('teams') { q.where(:name, 'sos') }
haruhi = q.get('members') { q.where(:name, 'Haruhi') }
<strong>hash = {:leader_id=&gt;haruhi['id'], :updated_at=&gt;:current_timestamp}</strong>
<strong>q.update('teams', hash) { q.where(:id, sos['id']) }</strong>
          #=&gt; update teams set leader_id = 1, updated_at = current_timestamp where id = 1
p q.select('teams', 'id, name, leader_id')
          #=&gt; [{"name"=&gt;"sos", "id"=&gt;1, "leader_id"=&gt;1},
          #    {"name"=&gt;"ryouou", "id"=&gt;2, "leader_id"=&gt;nil}]
</pre>
<p><code>Query#update('table', values, <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#update('table', values) {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="062__update2.rb"></a>
<pre class="program">### specify condition arguments
<strong>q.update('teams', hash, :id, sos['id'])</strong>
### this is equivarent to the following
#q.update('teams', hash) { q.where(:id, sos['id']) }
</pre>
<p>You must specify conditions for update(), or you'll get an error.
This is intended to avoid "accidential all update".
</p>
<a name="064_update4_error.rb"></a>
<pre class="program">### this will cause an error, because condition nor id is specified.
q.update('teams', values)    #=&gt; Kwery::Error
</pre>
<p>If you want to update all records, you must use update_all() instead of update().
</p>
<a name="065_update5.rb"></a>
<pre class="program">### update all records in teams table
<strong>q.update_all('teams', values)</strong>   #=&gt; update teams set ...
</pre>
<br>


<a name="delete from"></a>
<h3 class="section2">delete from</h3>
<p>Query#delete() deletes rows matched to condition.
</p>
<a name="071_delete_from1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
require 'pp'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### delete members of Ryouou
ryouou = q.get('teams') { q.where(:name, 'ryouou') }
<strong>q.delete('members') { q.where(:team_id, ryouou['id']) }</strong>
</pre>
<p><code>Query#delete('table', <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#delete('table') {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="072_delete_from2.rb"></a>
<pre class="program">### delete Ryouou
ryouou = q.get('teams') { q.where(:name, 'ryouou') }
<strong>q.delete('teams', :id, ryouou['id'])</strong>
### this is equivarent to the following
# q.delete('teams') { q.where(:id, ryouou['id']) }
</pre>
<p>You need to specify conditions or 'id' value, or you'll get an error.
This is intended to avoid "accidencall all deletion".
</p>
<a name="073_delete_from3_error.rb"></a>
<pre class="program">### this will raise error because no conditons nor no id is specified.
q.delete('members')    #=&gt; Kwery::Error
</pre>
<p>If you want to delete all records, you must use delete_all() instead of delete().
</p>
<a name="074_delete_from4.rb"></a>
<pre class="program">### delete all records in members table
<strong>q.delete_all('members')</strong>   #=&gt; delete from members
</pre>
<br>


<br>


<a name="Query (with model class)"></a>
<h2 class="section1">Query (with model class)</h2>
<a name="create table"></a>
<h3 class="section2">create table</h3>
<p>Kwery provides DSL to create tables.
</p>
<a name="models.rb"></a>
<div class="program_caption">
models.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'

class Team
  <strong>include Kwery::Model</strong>

  <strong>create_table('teams') do |t|</strong>
    <strong>t.integer(:id) {|c| c.primary_key.auto_increment }</strong>  # or serial
    <strong>t.string(:name, 255) {|c| c.not_null.unique }</strong>
    <strong>t.text(:desc)</strong>
    <strong>t.integer(:leader_id) {|c| c.references('members') }</strong>
    <strong>t.timestamp(:created_at) {|c| c.not_null }</strong>
    <strong>t.timestamp(:updated_at) {|c| c.not_null.default(:current_timestamp) }</strong>
  <strong>end</strong>

  attr_accessor :leader

end

class Member
  <strong>include Kwery::Model</strong>

  <strong>create_table('members') do |t|</strong>
    <strong>t.integer(:id) {|c| c.primary_key.auto_increment }</strong>  # or serial
    <strong>t.string(:name, 255) {|c| c.not_null }</strong>
    <strong>t.text(:desc)</strong>
    <strong>t.integer(:team_id) {|c| c.references('teams') }</strong>
    <strong>t.timestamp(:created_at) {|c| c.not_null }</strong>
    <strong>t.timestamp(:updated_at) {|c| c.not_null.default(:current_timestamp) }</strong>
  <strong>end</strong>

  attr_accessor :team

end

if __FILE__ == $0
  conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
  q = Kwery::Query.new(conn)
  q.output = $stderr     # reports SQL to $stderr
  sql = <strong>Team.to_sql</strong>
  puts sql   #=&gt;
             # create table teams (
             #   id                 integer         primary key auto_increment,
             #   name               varchar(255)    not null unique,
             #   `desc`             text           ,
             #   leader_id          integer         references members(id),
             #   created_at         timestamp       not null default 0,
             #   updated_at         timestamp       not null default current_timestamp
             # )
  q.execute(sql)
  sql = <strong>Member.to_sql</strong>
  puts sql   #=&gt;
             # create table members (
             #   id                 integer         primary key auto_increment,
             #   name               varchar(255)    not null,
             #   `desc`             text           ,
             #   team_id            integer         references teams(id),
             #   created_at         timestamp       not null default 0,
             #   updated_at         timestamp       not null default current_timestamp
             # )
  q.execute(sql)
end
</pre>
<p>Tips:
</p>
<ul type="disc">
<li><code>t.string(:column)</code> results in <code>t.string(:column, 255)</code>
</li>
<li><code>t.references(:column, 'table')</code> is equivarent to <code>t.integer(:column) { t.references('table') }</code>.
</li>
<li><code>t.unique(:column1, :column2, :column3)</code> is available to specify unique constrant which ranges several columns.
</li>
<li>Model class defines accessors automatically.
</li>
<li>Also Model#[] and Model#[] are defined. For example, <code>team[:name]</code> or <code>team['name']</code> is equivarent to <code>team.name</code>.
</li>
</ul>
<br>


<a name="insert into"></a>
<h3 class="section2">insert into</h3>
<p>Query#insert_model() and Query#insert() insert a row.
</p>
<a name="121_insert_into2.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
<strong>require 'models'</strong>
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## insert Model
sos = Team.new(nil, 'sos', 'SOS Brigate', nil)
sos.created_at = sos.updated_at = :current_timestamp
<strong>q.insert_model(sos)</strong>   #=&gt; insert into teams(name, `desc`, created_at, updated_at)
                            #   values ('sos', 'SOS Brigate', current_timestamp, current_timestap)
<strong>p sos.id</strong>   # id is set automatically
<strong>q.insert(Member.new(nil, 'Haruhi', nil, sos.id, :current_timestamp, :current_timestamp))</strong>
<strong>q.insert(Member.new(nil, 'Mikuru', nil, sos.id, :current_timestamp, :current_timestamp))</strong>
<strong>q.insert(Member.new(nil, 'Yuki',   nil, sos.id, :current_timestamp, :current_timestamp))</strong>

## insert Hash
ryouou = {:name=&gt;'ryouou', :desc=&gt;'Ryouou High-School',
          :created_at=&gt;:current_timestamp, :updated_at=&gt;:current_timestamp}
ryouou
<strong>q.insert(Team, ryouou)</strong>   #=&gt; insert into teams(name, `desc`, created_at, updated_at)
                               #   values ('ryouou', 'Ryouou High-School', current_timestamp, current_timestamp)
id = q.last_insert_id
now = :current_timestamp
<strong>q.insert(Member, {:name=&gt;'Konata',  :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert(Member, {:name=&gt;'Kagami',  :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert(Member, {:name=&gt;'Tsukasa', :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
<strong>q.insert(Member, {:name=&gt;'Miyuki',  :team_id=&gt;id, :created_at=&gt;now, :updated_at=&gt;now})</strong>
#+++
require 'pp'
pp q.get_all(Team)
pp q.get_all(Member)
#---
</pre>
<br>


<a name="select from"></a>
<h3 class="section2">select from</h3>
<p>There are several methods for 'select from'.
</p>
<a name="get()"></a>
<h4 class="section3">get()</h4>
<p>Kwery::Query#get() returns a row.
</p>
<a name="131_get1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
<strong>require 'models'</strong>
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## get model object
<strong>sos = q.get(Team) {|c| c.where(:id, 1) }</strong>
p sos     #=&gt; #&lt;Team @id=1, @name=&gt;"sos", @desc="SOS Brigate", @leader_id=&gt;nil, ... &gt;
<strong>haruhi = q.get(Member) {|c| c.where(:name, 'Haruhi') }</strong>
p haruhi  #=&gt; #&lt;Team @id=1, @name="Haruhi", @desc=nil, @team_id=1, ... &gt;
</pre>
<p>The followings are equivarent each other.
</p>
<ul type="disc">
<li>q.get(Member) { q.where(:name, 'Haruhi') }
</li>
<li>q.get(Member) { q.where('name', 'Haruhi') }
</li>
<li>q.get(Member) { q.where('name = ', 'Haruhi') }
</li>
<li>q.get(Member) { q.where('name = %s', ['Haruhi']) }
</li>
<li>q.get(Member) { q.where("name = 'Haruhi'") }
</li>
</ul>
<p>You can specify several 'where' conditions.
</p>
<a name="132_get2.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get(Member) {|c|
  <strong>c.where(:team_id, sos.id).where('created_at &gt;', t).where_is_not_null(:desc)</strong>
}
### or
members = q.get(Member) {|c|
  c.where(:team_id, sos.id)
  c.where('created_at &gt;', t)
  c.where_is_not_null(:desc)
}
</pre>
<p><code>Query#get(ModelClass, <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#get(ModelClass) {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="133_get3.rb"></a>
<pre class="program">### select row with condition
haruhi = q.get(Member, :name, 'Haruhi')
### This is equvarent to the following.
#haruhi = q.get(Member) {|c| c.where(:name, 'Haruhi') }
</pre>
<br>

<a name="get_all()"></a>
<h4 class="section3">get_all()</h4>
<p>Kwery::Query#get() returns all rows matched to condition.
</p>
<a name="141_get_all1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
<strong>require 'models'</strong>
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## get all members of SOS Brigate
sos = q.get(Team) { q.where(:name, 'sos') }
<strong>members = q.get_all(Member) { q.where(:team_id, sos.id) }</strong>
for member in members
  p member  #=&gt; #&lt;Member @id=1, @name="Haruhi", @team_id=1, ... &gt;
            #=&gt; #&lt;Member @id=2, @name="Mikuru", @team_id=1, ... &gt;
	    #=&gt; #&lt;Member @id=3, @name="Yuki", @team_id=1, ... &gt;
end
</pre>
<p>You can specify several 'where' conditions.
</p>
<a name="142_get_all2.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get_all(Member) {|c|
  <strong>c.where(:team_id, sos.id]).where('created_at &gt;', t).where_is_not_null(:desc)</strong>
}
### or
members = q.get_all(Member) {|c|
  c.where(:team_id, sos.id])
  c.where('created_at &gt;', t)
  c.where_is_not_null(:desc)
}
</pre>
<p>'order_by', 'group_by', 'having', 'limit' are also available.
</p>
<a name="143_get_all3.rb"></a>
<pre class="program">t = Time.mktime(1990, 7, 7)
members = q.get_all(Member) {|c|
  c.where(:team_id, sos.id)<strong>.order_by(:id).limit(0, 2)</strong>
}
</pre>
<p><code>Query#get_all(ModelClass, <em>arg1</em>, <em>arg2</em>)</code> is equivarent to <code>Query#get_all(ModelClass) {|c| c.where(<em>arg1</em>, <em>arg2</em>) }</code>.
</p>
<a name="144_get_all4.rb"></a>
<pre class="program">members = <strong>q.get_all(Member, :team_id, sos.id)</strong>
### This is equivarent to the following
#members = q.get_all(Member) {|c| c.where(:team_id, sos.id) }
</pre>
<br>

<a name="select()"></a>
<h4 class="section3">select()</h4>
<p>Kwery::Query#select() returns all rows matched to conditions.
It is able to specify select colums by Query#select().
</p>
<a name="151_select_from1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
<strong>require 'models'</strong>
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### select only id and name columns
sos = q.get(Team) { q.where(:name, 'sos') }
<strong>members = q.select(Member, 'id, name') { q.where(:team_id, sos.id) }</strong>
p members    #=&gt; [#&lt;Member @name="Haruhi", @id=1&gt;,
             #    #&lt;Member @name="Mikuru", @id=2&gt;,
             #    #&lt;Member @name="Yuki", @id=3&gt;]
</pre>
<p>It is able to specify class object as which records are get.
</p>
<a name="152_select_form2.rb"></a>
<pre class="program">### specify to get as Array instead of Hash
members = q.select(Member, 'id, name', <strong>Array</strong>) { q.where(:team_id, sos.id) }
p members   #=&gt; [[1, 'Haruhi'], [2, 'Mikuru'], [3, 'Yuki']]
</pre>
<p>Currently it is not available to specify several model classes in select().
</p>
<a name="153_select_from3.rb"></a>
<pre class="program">## currently not available
records = q.select(<strong>[Member, Team]</strong>, '*', Array) {
  <strong>q.where('members.team_id = teams.id')</strong>
}
</pre>
<p>Left outer join is available.
</p>
<a name="155_select_from5.rb"></a>
<pre class="program">records = q.select(<strong>Team</strong>, '*', Array) {
  <strong>q.left_outer_join(Member, 'leader_id')</strong>
}
p records  #=&gt; [[1, "sos", "SOS Brigate", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
           #    1, "Haruhi", nil, 1, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;],
           #    [2, "ryouou", "Ryouou Hight-School", nil, #&lt;Mysql::Time&gt;, #&lt;Mysql::Time&gt;,
           #    nil, nil, nil, nil, nil, nil]]
</pre>
<p>The following is an example to count members for each teams.
</p>
<a name="156_select_count6.rb"></a>
<pre class="program">records = q.select('teams, members', 'teams.id, count(*) count', Array) {|c|
  c.where('teams.id = members.team_id').group_by('teams.id').order_by('teams.id')
}
      #=&gt; select teams.id, count(*) count from teams, members
      #   where teams.id = members.team_id
      #   group by teams.id
      #   order by teams.id

p records    #=&gt; [[1, 3], [2, 4]]

records = q.select('teams t, members m', 't.id, t.name, count(*) count', Array) {|c|
  c.where('t.id = m.team_id').group_by('t.id, t.name').order_by('t.id')
}
      #=&gt; select t.id, t.name, count(*) count from teams t, members m
      #   where t.id = m.team_id 
      #   group by t.id, t.name 
      #   order by t.id

p records    #=&gt; [[1, "sos", 3], [2, "ryouou", 4]]
</pre>
<br>

<br>


<a name="update"></a>
<h3 class="section2">update</h3>
<p>Query#update_model() updates an model object. It updates only a row and not able to specify any conditions.
</p>
<p>Query#update() updates can update several rows matched to conditions.
</p>
<a name="161_update1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
require 'models'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### update model object
### (only changed attributes are updated in sql.)
haruhi = q.get(Member) { q.where(:name, 'Haruhi') }
haruhi.desc = 'Leader of SOS Brigade'
<strong>q.update_model(haruhi)</strong>  #=&gt; update members set `desc`='Leader of SOS Brigade' where id = 1
p q.get(Member, :id, haruhi.id) #=&gt; #&lt;Member @id=1, @name='Haruhi', @desc=&gt;'Leader of SOS Brigade', ...&gt;

### update rows
sos = q.get(Team) { q.where(:name, 'sos') }
<strong>hash = {:leader_id=&gt;haruhi.id, :updated_at=&gt;:current_timestamp}</strong>
<strong>q.update(Team, hash) { q.where(:id, sos.id) }</strong>
p q.select(Team, 'id, name, leader_id')
    #=&gt; [#&lt;Team @id=1, @name="sos", @leader_id=1&gt;,
    #    #&lt;Team @id=2, @name="ryouou", @leader_id=nil&gt;]
</pre>
<p>You can specify condition arguments to Query#update().
</p>
<a name="162_update2.rb"></a>
<pre class="program">### specify 'id' as condition
<strong>q.update(Team, hash, :id, sos.id)</strong>
### this is equivarent to the following
#q.update(Team, hash) { q.where(:id, sos.id) }
</pre>
<p>You must specify conditions for Query#update(), or you'll get an error.
This is intended to avoid "accidential all update".
</p>
<a name="164_update4_error.rb"></a>
<pre class="program">### this will cause an error, because condition nor id is specified.
q.update(Team, values)    #=&gt; Kwery::Error
</pre>
<p>If you want to update all records, you must use Query#update_all() instead of update().
</p>
<a name="165_update5.rb"></a>
<pre class="program">### update all records in teams table
<strong>q.update_all(Team, values)</strong>   #=&gt; update teams set ....
</pre>
<br>


<a name="delete from"></a>
<h3 class="section2">delete from</h3>
<p>Query#delete_model() deletes a row of model data.
</p>
<p>Query#delete() deletes rows matched to condition.
</p>
<a name="171_delete_from1.rb"></a>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
require 'models'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### delete model object
miyuki = q.get(Member) {|c| c.where(:name, 'Miyuki') }
q.delete_model(miyuki)    #=&gt; delete from members where id = 7

### delete rows
ryouou = q.get(Team) { q.where(:name, 'ryouou') }
<strong>q.delete(Member) { q.where(:team_id, ryouou.id) }</strong>
                     #=&gt; delete from members where team_id = 2
p q.select(Member)   #=&gt; [#&lt;Member @name="Haruhi", @team_id=1, ...&gt;,
                     #    #&lt;Member @name="Mikuru", @team_id=1, ...&gt;,
                     #    #&lt;Member @name="Yuki", @team_id=1, ...&gt;]
</pre>
<p>It is able to specify condition arguments to Query#delete().
</p>
<a name="172_delete_from2.rb"></a>
<pre class="program">### delete rows
ryouou = q.get(Team) { q.where(:name, 'ryouou') }
<strong>q.delete(Member, :team_id, ryouou.id)</strong>
### this is equivarent to the following
# q.delete(Member) { q.where(:team_id, ryouou.id) }
</pre>
<p>You need to specify any conditions, or you'll get an error.
This is intended to avoid "accidencall all deletion".
</p>
<a name="173_delete_from3_error.rb"></a>
<pre class="program">### this will raise error because no conditons nor no id is specified.
q.delete(Member)   #=&gt; Kwery::Error
</pre>
<p>If you want to delete all records, you must use delete_all() instead of delete().
</p>
<a name="174_delete_from4.rb"></a>
<pre class="program">### delete all records in members table
<strong>q.delete_all(Member)</strong>   #=&gt; delete from members
</pre>
<br>


<br>


<a name="Relation"></a>
<h2 class="section1">Relation</h2>
<a name="N : 1 (belongs to)"></a>
<h3 class="section2">N : 1 (belongs to)</h3>
<p>Kwery doesn't support relations(!).
Instead, some helper functions are provided.
</p>
<p>Query#bind_references_to() is provided for 'belongs-to' relations.
</p>
<p>Assume that the following tables.
</p>
<pre class="program">mysql&gt; select * from teams;  
+----+--------+--------------------+-----------+
| id | name   | desc               | leader_id |
+----+--------+--------------------+-----------+
|  1 | sos    | SOS Brigate        |         1 |
|  2 | ryouou | Ryouou High-School |         4 |
+----+--------+--------------------+-----------+

mysql&gt; select * from members;
+----+---------+---------+
| id | name    | team_id |
+----+---------+---------+
|  1 | Haruhi  |       1 | 
|  2 | Mikuru  |       1 | 
|  3 | Yuki    |       1 | 
|  4 | Konata  |       2 | 
|  5 | Kagami  |       2 | 
|  6 | Tsukasa |       2 | 
|  7 | Miyuki  |       2 | 
+----+---------+---------+
</pre>
<p>In this case, you can avoid '1+N' problem by Query#bind_references_to().
</p>
<dl class="dl2">
<dt class="dt2">
bind_references_to(items, table, column, attr, not_null=true)</dt>
<dd class="dd2">
	<dl class="dl3" compact>
	<dt class="dt3"><b>
items</b></dt>
	<dd class="dd3">
		array of hash, or array of model objects
	</dd>
	<dt class="dt3"><b>
table</b></dt>
	<dd class="dd3">
		table name string, or model class.
	</dd>
	<dt class="dt3"><b>
column</b></dt>
	<dd class="dd3">
		foreign key name (string)
	</dd>
	<dt class="dt3"><b>
attr</b></dt>
	<dd class="dd3">
			attribute name (string or symbol)
	</dd>
	<dt class="dt3"><b>
no_tull</b></dt>
	<dd class="dd3">
		set false if foreign key is nullable.
	</dd>
	</dl>
</dd>
</dl>
<a name="ex301.rb"></a>
<div class="program_caption">
ex301.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all members
members = q.get_all('members') {|c| c.order_by(:id) }
    #=&gt; select * from members order by id

## set related team to each member
## (model class object is available as table name)
<strong>q.bind_references_to(members, 'teams', 'team_id', 'team')</strong>
    #=&gt; select * from teams where id in (1,1,1,2,2,2,2)

## show members
for m in members
  team = m['team']
  puts "%2d, %7s, %2d, %7s" % [m['id'], m['name'], team['id'], team['name']]
end
</pre>
<div class="terminal_caption">
result</div>
<pre class="terminal">$ ruby ex301.rb
 1,  Haruhi,  1,     sos
 2,  Mikuru,  1,     sos
 3,    Yuki,  1,     sos
 4,  Konata,  2,  ryouou
 5,  Kagami,  2,  ryouou
 6, Tsukasa,  2,  ryouou
 7,  Miyuki,  2,  ryouou
</pre>
<p>Query#bind_references_to() avoids '1+N' problem by <code>where-in</code> condition.
</p>
<br>


<a name="1 : N (has many)"></a>
<h3 class="section2">1 : N (has many)</h3>
<p>Query#bind_referenced_from() is a reverse of bind_references_to().
</p>
<dl class="dl2">
<dt class="dt2">
bind_references_to(items, table, column, attr, not_null=true, multiple=true)</dt>
<dd class="dd2">
	<dl class="dl3" compact>
	<dt class="dt3"><b>
items</b></dt>
	<dd class="dd3">
		array of hash, or array of model objects
	</dd>
	<dt class="dt3"><b>
table</b></dt>
	<dd class="dd3">
		table name string, or model class.
	</dd>
	<dt class="dt3"><b>
column</b></dt>
	<dd class="dd3">
		foreign key name (string)
	</dd>
	<dt class="dt3"><b>
attr</b></dt>
	<dd class="dd3">
			attribute name (string or symbol)
	</dd>
	<dt class="dt3"><b>
not_null</b></dt>
	<dd class="dd3">
		set false if foreign key is nullable.
	</dd>
	<dt class="dt3"><b>
multiple</b></dt>
	<dd class="dd3">
		set false when has-one relation.
	</dd>
	</dl>
</dd>
</dl>
<a name="ex302.rb"></a>
<div class="program_caption">
ex302.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all teams
teams = q.get_all('teams') {|c| c.order_by(:id) }
    #=&gt; select * from teams order by id

## set related members to each team
## (model class object is available as table name)
<strong>q.bind_referenced_from(teams, 'members', 'team_id', 'all_members')</strong>
    #=&gt; select * from members where team_id in (1,2)

## inspect members
require 'pp'
pp teams
</pre>
<div class="terminal_caption">
result (modified for readability)</div>
<pre class="terminal">$ ruby ex302.rb
[
  {
    "id"   =&gt; 1,
    "name" =&gt; "sos",
    "desc" =&gt; "SOS Brigate",
    "leader_id" =&gt; 1,
    "all_members" =&gt; [
      {"id"=&gt;1, "team_id"=&gt;1, "name"=&gt;"Haruhi"},
      {"id"=&gt;2, "team_id"=&gt;1, "name"=&gt;"Mikuru"},
      {"id"=&gt;3, "team_id"=&gt;1, "name"=&gt;"Yuki"  },
    ],
  },
  {
    "id"   =&gt; 2,
    "name" =&gt; "ryouou",
    "desc" =&gt; "Ryouou High-School",
    "leader_id" =&gt; 4,
    "all_members" =&gt; [
      {"id"=&gt;4, "team_id"=&gt;2, "name"=&gt;"Konata" },
      {"id"=&gt;5, "team_id"=&gt;2, "name"=&gt;"Kagami" },
      {"id"=&gt;6, "team_id"=&gt;2, "name"=&gt;"Tsukasa"},
      {"id"=&gt;7, "team_id"=&gt;2, "name"=&gt;"Miyuki" },
    ],
  },
]
</pre>
<br>


<a name="1 : 1 (has one)"></a>
<h3 class="section2">1 : 1 (has one)</h3>
<p>Query#bind_referenced_from() can handle has-one relation.
</p>
<a name="ex303.rb"></a>
<div class="program_caption">
ex303.rb</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all members
members = q.get_all('members') {|c| c.order_by(:id) }
    #=&gt; select * from members order by id

## set related teams which each member owns.
## (model class object is available as table name)
<strong>q.bind_referenced_from(members, 'teams', 'leader_id', 'lead', false, false)</strong>
    #=&gt; select * from teams where leader_id in (1,2,3,4,5,6,7)

## inspect members
require 'pp'
pp members
</pre>
<div class="terminal_caption">
result (only Haruhi and Konata have their own team)</div>
<pre class="terminal"># ruby ex303.rb
[{"team_id"=&gt;1,
  "name"=&gt;"Haruhi",
  "id"=&gt;1,
  "lead"=&gt;{"name"=&gt;"sos", "id"=&gt;1, "desc"=&gt;"SOS Brigate", "leader_id"=&gt;1}},
 {"team_id"=&gt;1, "name"=&gt;"Mikuru", "id"=&gt;2, "lead"=&gt;nil},
 {"team_id"=&gt;1, "name"=&gt;"Yuki", "id"=&gt;3, "lead"=&gt;nil},
 {"team_id"=&gt;2,
  "name"=&gt;"Konata",
  "id"=&gt;4,
  "lead"=&gt;
   {"name"=&gt;"ryouou", "id"=&gt;2, "desc"=&gt;"Ryouou High-School", "leader_id"=&gt;4}},
 {"team_id"=&gt;2, "name"=&gt;"Kagami", "id"=&gt;5, "lead"=&gt;nil},
 {"team_id"=&gt;2, "name"=&gt;"Tsukasa", "id"=&gt;6, "lead"=&gt;nil},
 {"team_id"=&gt;2, "name"=&gt;"Miyuki", "id"=&gt;7, "lead"=&gt;nil}]
</pre>
<br>


<a name="N : M (has many through)"></a>
<h3 class="section2">N : M (has many through)</h3>
<p>Query#select() can handle N : M relation.
</p>
<p>For example, assume the folloing tables.
</p>
<pre class="program">create table tags (
  id       integer        primary key auto_increment,
  name     varchar(255)   not null unique
);

create table posts (
  id       integer        primary key auto_increment,
  title    varchar(255)   not null,
  content  text           not null
);

create table taggings (
  id       integer        primary key auto_increment,
  tag_id   integer        not null references tags(id),
  post_id  integer        not null references posts(id)
);
</pre>
<p>The following is an example to handle N : M relation by Query#select().
</p>
<a name="ex304.rb"></a>
<div class="program_caption">
ex304.rb : select all posts which are tagged as 'anime'</div>
<pre class="program">require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr

posts = q.select(<strong>'posts, tags, taggings'</strong>, 'posts.*') {|c|
  <strong>c.where('tags.id = taggings.tag_id')</strong>
  <strong>c.where('posts.id = taggings.post_id')</strong>
  c.where('tags.name', 'anime')
}
      #=&gt; select posts.* from posts, tags, taggings
      #   where tags.id = taggings.tag_id
      #     and posts.id = taggings.post_id
      #     and tags.name = 'anime'
</pre>
<br>


<br>



   </div>
  </blockquote>

 </body>
</html>
