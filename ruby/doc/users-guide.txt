.=title:	Kwery User's Guide
.?release:	$Release$
.?copyright:	$Copyright$
.?lastupdate:	$Date: $
.?stylesheet:	docstyle.css



.$ Preface

Kwery is a pretty database library.
You can use Kwery as database library (like DBI), or as O/R Mapper.

Features:

.* Kwery is very small and lightweight.
   It is suitable especially for CGI script.
.* It is not necessary to define model class.
   If you don't define model class, you can use Hash object instead of model object.
.* You can define model class to map tables (optional).
.* It is very easy to use Kwery if you already know SQL.
.* Currently Kwery supports only MySQL, but it will be easy to support other RDBMS.
.* Kwery doesn't have validation functionality currently.

Example:

.-------------------- 000_exaple.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Qwery.new(conn)
q.output = $stderr  # for debug

## select * from teams where id = 123
team = q.get('teams') {|c| c.where(:id, 123) }
		    # or q.get('teams', :id, 123)

## select * from members
## where team_id = team['id'] and created_at > '2008-01-01'
## order by name desc
t = Time.mktime(2008, 1, 1)
members = q.get_all('members') {|c|
  c.where(:team_id, team['id']).where('created_at >', t).order_by_desc(:name)
}

## insert into teams(name, desc) values('sos', 'SOS Brigade')
q.insert('teams', {:name=>'sos', :desc=>'SOS Brigade'})

## update teams set name='sos', `desc`='SOS Brigade' where id = 123
values = {:name=>'sos', :desc=>'SOS Brigade'}
q.update('teams', values) {|c| c.where(:id, 123) }
                    # or q.update('teams', values, :id, 123)

## delete from members where name == 'taniguchi'
q.delete('members') {|c| c.where(:name, 'taniguchi') }
                    # or q.delete('teams', :name, 'taniguchi')
.--------------------


.$$ Table of contents

.<<< users-guide.toc


.$ Query (without model class)

.#+++
.-------------------- setup.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
$q = Kwery::Query.new(conn)
$q.output = $stderr
require 'pp'
.--------------------
.#---


.$$ create table

.? create_tables1.rb
.-------------------- 011_create_tables1.rb
{{*require 'kwery'*}}
{{*require 'kwery/adapters/mysql'*}}

sql1 = <<END
create table teams (
  id          integer       primary key auto_increment,
  name        varchar(255)  not null unique,
  `desc`      text,
  leader_id   integer       references members(id),
  created_at  timestamp,
  updated_at  timestamp
) engine=InnoDB
END

sql2 = <<END
create table members (
  id          integer       primary key auto_increment,
  name        varchar(255)  not null,
  `desc`      text,
  team_id     integer       not null,
  created_at  timestamp,
  updated_at  timestamp
) engine=InnoDB
END

## create Query object
{{*conn = Kwery.connect('localhost', 'username', 'password', 'dbname')*}}
{{*q = Kwery::Query.new(conn)*}}
q.output = $stderr     #=> reports SQL to $stderr

## Query#execute() executes any kind of SQL
{{*q.execute(sql1)*}}
{{*q.execute(sql2)*}}
.--------------------


.$$ insert into

.? insert_into1.rb
.-------------------- 021_insert_into1.rb
require 'kwery'
require 'kwery/adapters/mysql'

conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## insert Array
{{*q.insert('teams', [nil, 'sos', 'SOS Brigate', nil, :current_timestamp, :current_timestamp])*}}
{{*id = q.last_insert_id*}}  # get sos's id
{{*q.insert('members', [nil, 'Haruhi', nil, id, :current_timestamp, :current_timestamp])*}}
{{*q.insert('members', [nil, 'Mikuru', nil, id, :current_timestamp, :current_timestamp])*}}
{{*q.insert('members', [nil, 'Yuki', nil, id, :current_timestamp, :current_timestamp])*}}

## insert Hash
{{*q.insert('teams', {:name=>'ryouou', :desc=>'Ryouou Hight-School',*}}
                    {{*:created_at=>:current_timestamp, :updated_at=>:current_timestamp})*}}
{{*id = q.last_insert_id*}}  # get ryouou's id
{{*now = :current_timestamp*}}
{{*q.insert('members', {:name=>'Konata', :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert('members', {:name=>'Kagami', :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert('members', {:name=>'Tsukasa', :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert('members', {:name=>'Miyuki', :team_id=>id, :created_at=>now, :updated_at=>now})*}}
.--------------------


.$$ select from

There are several methods for 'select from'.


.$$$ get()

Kwery::Query#get() returns a row.

.? get1.rb
.-------------------- 031_get1.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### get row
{{*sos = q.get('teams') {|c| c.where(:id, 1)*}}
          #=> select * from teams where id = 1
p sos     #=> {"id"=>1, "name"=>"sos", "desc"=>"SOS Brigate", "leader_id"=>nil, ... }
{{*haruhi = q.get('members') {|c| c.where(:name, 'Haruhi')*}}
          #=> select * from members where name = 'Haruhi'
p haruhi  #=> {"id"=>1, "name="Haruhi", "desc"=>nil, "team_id"=>1, ... }
.--------------------

The followings are equivarent each other.

.* q.get('members') { q.where(:name, 'Haruhi') }
.* q.get('members') { q.where('name', 'Haruhi') }
.* q.get('members') { q.where('name = ', 'Haruhi') }
.* q.get('members') { q.where('name = %s', ['Haruhi']) }
.* q.get('members') { q.where("name = 'Haruhi'") }

You can specify several 'where' conditions.

.-------------------- 032_get2.rb
t = Time.mktime(1990, 7, 7)
members = q.get('members') {|c|
  {{*c.where(:team_id, sos['id']).where('created_at >', t).where_is_not_null(:desc)*}}
}
### or
members = q.get('members') {|c|
  c.where(:team_id, sos['id'])
  c.where('created_at >', t)
  c.where_is_not_null(:desc)
}
.--------------------

{{,Query#get('table', {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#get('table') {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 033_get3.rb
### select row with condition
haruhi = q.get('members', :name, 'Haruhi')
### This is equvarent to the following.
#haruhi = q.get('members') {|c| c.where(:name, 'Haruhi') }
.--------------------


.$$$ get_all()

Kwery::Query#get() returns all rows matched to condition.

.? get_all1.rb
.-------------------- 041_get_all1.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## SOS Brigate
sos = q.get('teams') { q.where(:name, 'sos') }

## get all members of SOS Brigate
{{*members = q.get_all('members') { q.where(:team_id, sos['id']) }*}}
            #=> select * from members where team_id = 1
for member in members
  p member  #=> {"id"=>1, "name"=>"Haruhi", "team_id"=>1, ...}
            #=> {"id"=>2, "name"=>"Mikuru", "team_id"=>1, ... }
	    #=> {"id"=>3, "name"=>"Yuki", "team_id"=>1, ... }
end
.--------------------

You can specify several 'where' conditions.

.-------------------- 042_get_all2.rb
t = Time.mktime(1990, 7, 7)
members = q.get_all('members') {|c|
  {{*c.where(:team_id, sos['id']).where('created_at >', t).where_is_not_null(:desc)*}}
}
### or
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id'])
  c.where('created_at >', t)
  c.where_is_not_null(:desc)
}
.--------------------

'order_by', 'group_by', 'having', 'limit' are also available.

.-------------------- 043_get_all3.rb
t = Time.mktime(1990, 7, 7)
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id']){{*.order_by(:id).limit(0, 2)*}}
}
### or
members = q.get_all('members') {|c|
  c.where(:team_id, sos['id'])
  c.order_by(:id)
  c.limit(0, 2)
}
.--------------------

{{,Query#get_all('table', {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#get_all('table') {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 044_get_all4.rb
members = {{*q.get_all('members', :team_id, ryouou['id'])*}}
### This is equivarent to the following
#members = q.get_all('members') {|c| c.where(:team_id, ryouou['d']) }
.--------------------


.$$$ select()

Kwery::Query#select() returns all rows matched to conditions.
It is able to specify select colums by Query#select().

.-------------------- 051_select_from1.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### select only id and name columns
sos = q.get('teams') { q.where(:name, 'sos') }
members = {{*q.select('members', 'id, name') { q.where(:team_id, sos['id']) }*}}
p members    #=> [{"name"=>"Haruhi", "id"=>1},
             #    {"name"=>"Mikuru", "id"=>2},
             #    {"name"=>"Yuki", "id"=>3}]
.--------------------

It is able to specify class object as which records are get.

.-------------------- 052_select_form2.rb
### specify to get as Array instead of Hash
members = q.select('members', 'id, name', {{*Array*}}) { q.where(:team_id, sos['id']) }
p members   #=> [[1, 'Haruhi'], [2, 'Mikuru'], [3, 'Yuki']]
.--------------------

If you want to join tables, specify table names in select().

.-------------------- 053_select_from3.rb
records = q.select({{*'members, teams'*}}, '*', Array) {|c|
  {{*c.where('members.team_id = teams.id')*}}
  c.where('teams.name =', 'sos')
}
require 'pp'
pp records  #=> [[1, "Haruhi", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
            #     1, "sos", "SOS Brigae", nil, #<Mysql::Time>, #<Mysql::Time>],
            #    [2, "Mikuru", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
            #     1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>],
            #    [3, "Yuki", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
            #     1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [4, "Konata", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [5, "Kagami", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [6, "Tsukasa", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [7, "Miyuki", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>]]
.--------------------

You can select only a certain table's record when joining.

.-------------------- 054_select_from4.rb
records = q.select('members, teams', {{*'members.*'*}}) {|c|
  c.where('members.team_id = teams.id')
  c.where('teams.name =', 'sos')
}
p records  #=> [{"id"=>1, "name"=>"Haruhi", "team_id"=>1, ... },
           #    {"id"=>2, "name"=>"Mikuru", "team_id"=>1, ... },
           #    {"id"=>3, "name"=>"Yuki", "team_id"=>1, ... }]
.--------------------

Left outer join is available.

.-------------------- 055_select_from5.rb
records = q.select({{*'teams'*}}, '*', Array) {|c|
  {{*c.left_outer_join('members', 'leader_id')*}}
}
p records  #=> [[1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>,
           #    1, "Haruhi", nil, 1, #<Mysql::Time>, #<Mysql::Time>],
           #    [2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>,
           #    nil, nil, nil, nil, nil, nil]]
.--------------------

The following is an example to count members for each teams.

.-------------------- 056_select_count6.rb
.#+++
require 'setup'
q = $q
.#---
records = q.select('teams, members', 'teams.id, count(*) count', Array) {|c|
  c.where('teams.id = members.team_id').group_by('teams.id').order_by('teams.id')
}
      #=> select teams.id, count(*) count from teams, members
      #   where teams.id = members.team_id
      #   group by teams.id
      #   order by teams.id

p records    #=> [[1, 3], [2, 4]]

records = q.select('teams t, members m', 't.id, t.name, count(*) count', Array) {|c|
  c.where('t.id = m.team_id').group_by('t.id, t.name').order_by('t.id')
}
      #=> select t.id, t.name, count(*) count from teams t, members m
      #   where t.id = m.team_id 
      #   group by t.id, t.name 
      #   order by t.id

p records    #=> [[1, "sos", 3], [2, "ryouou", 4]]
.--------------------


.$$ update

Query#update() updates data matched to conditions.

.-------------------- 061_update1.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### update column
sos = q.get('teams') { q.where(:name, 'sos') }
haruhi = q.get('members') { q.where(:name, 'Haruhi') }
{{*hash = {:leader_id=>haruhi['id'], :updated_at=>:current_timestamp}*}}
{{*q.update('teams', hash) { q.where(:id, sos['id']) }*}}
          #=> update teams set leader_id = 1, updated_at = current_timestamp where id = 1
p q.select('teams', 'id, name, leader_id')
          #=> [{"name"=>"sos", "id"=>1, "leader_id"=>1},
          #    {"name"=>"ryouou", "id"=>2, "leader_id"=>nil}]
.--------------------

{{,Query#update('table', values, {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#update('table', values) {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 062__update2.rb
### specify condition arguments
{{*q.update('teams', hash, :id, sos['id'])*}}
### this is equivarent to the following
#q.update('teams', hash) { q.where(:id, sos['id']) }
.--------------------

You must specify conditions for update(), or you'll get an error.
This is intended to avoid "accidential all update".

.-------------------- 064_update4_error.rb
### this will cause an error, because condition nor id is specified.
q.update('teams', values)    #=> Kwery::Error
.--------------------

If you want to update all records, you must use update_all() instead of update().

.-------------------- 065_update5.rb
### update all records in teams table
{{*q.update_all('teams', values)*}}   #=> update teams set ...
.--------------------


.$$ delete from

Query#delete() deletes rows matched to condition.

.-------------------- 071_delete_from1.rb
require 'kwery'
require 'kwery/adapters/mysql'
require 'pp'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### delete members of Ryouou
ryouou = q.get('teams') { q.where(:name, 'ryouou') }
{{*q.delete('members') { q.where(:team_id, ryouou['id']) }*}}
.--------------------

{{,Query#delete('table', {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#delete('table') {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 072_delete_from2.rb
### delete Ryouou
ryouou = q.get('teams') { q.where(:name, 'ryouou') }
{{*q.delete('teams', :id, ryouou['id'])*}}
### this is equivarent to the following
# q.delete('teams') { q.where(:id, ryouou['id']) }
.--------------------

You need to specify conditions or 'id' value, or you'll get an error.
This is intended to avoid "accidencall all deletion".

.-------------------- 073_delete_from3_error.rb
### this will raise error because no conditons nor no id is specified.
q.delete('members')    #=> Kwery::Error
.--------------------

If you want to delete all records, you must use delete_all() instead of delete().

.-------------------- 074_delete_from4.rb
### delete all records in members table
{{*q.delete_all('members')*}}   #=> delete from members
.--------------------


.$ Query (with model class)


.$$ create table

Kwery provides DSL to create tables.

.? models.rb
.-------------------- models.rb
require 'kwery'
require 'kwery/adapters/mysql'

class Team
  {{*include Kwery::Model*}}

  {{*create_table('teams') do |t|*}}
    {{*t.integer(:id) {|c| c.primary_key.auto_increment }*}}  # or serial
    {{*t.string(:name, 255) {|c| c.not_null.unique }*}}
    {{*t.text(:desc)*}}
    {{*t.integer(:leader_id) {|c| c.references('members') }*}}
    {{*t.timestamp(:created_at) {|c| c.not_null }*}}
    {{*t.timestamp(:updated_at) {|c| c.not_null.default(:current_timestamp) }*}}
  {{*end*}}

  attr_accessor :leader

end

class Member
  {{*include Kwery::Model*}}

  {{*create_table('members') do |t|*}}
    {{*t.integer(:id) {|c| c.primary_key.auto_increment }*}}  # or serial
    {{*t.string(:name, 255) {|c| c.not_null }*}}
    {{*t.text(:desc)*}}
    {{*t.integer(:team_id) {|c| c.references('teams') }*}}
    {{*t.timestamp(:created_at) {|c| c.not_null }*}}
    {{*t.timestamp(:updated_at) {|c| c.not_null.default(:current_timestamp) }*}}
  {{*end*}}

  attr_accessor :team

end

if __FILE__ == $0
  conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
  q = Kwery::Query.new(conn)
  q.output = $stderr     # reports SQL to $stderr
  sql = {{*Team.to_sql*}}
  puts sql   #=>
             # create table teams (
             #   id                 integer         primary key auto_increment,
             #   name               varchar(255)    not null unique,
             #   `desc`             text           ,
             #   leader_id          integer         references members(id),
             #   created_at         timestamp       not null default 0,
             #   updated_at         timestamp       not null default current_timestamp
             # )
  q.execute(sql)
  sql = {{*Member.to_sql*}}
  puts sql   #=>
             # create table members (
             #   id                 integer         primary key auto_increment,
             #   name               varchar(255)    not null,
             #   `desc`             text           ,
             #   team_id            integer         references teams(id),
             #   created_at         timestamp       not null default 0,
             #   updated_at         timestamp       not null default current_timestamp
             # )
  q.execute(sql)
end
.--------------------

Tips:

.* {{,t.string(:column),}} results in {{,t.string(:column, 255),}}
.* {{,t.references(:column, 'table'),}} is equivarent to {{,t.integer(:column) { t.references('table') },}}.
.* {{,t.unique(:column1, :column2, :column3),}} is available to specify unique constrant which ranges several columns.
.* Model class defines accessors automatically.
.* Also Model#[] and Model#[] are defined. For example, {{,team[:name],}} or {{,team['name'],}} is equivarent to {{,team.name,}}.


.$$ insert into

Query#insert_model() and Query#insert() insert a row.

.-------------------- 121_insert_into2.rb
require 'kwery'
require 'kwery/adapters/mysql'
{{*require 'models'*}}
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## insert Model
sos = Team.new(nil, 'sos', 'SOS Brigate', nil)
sos.created_at = sos.updated_at = :current_timestamp
{{*q.insert_model(sos)*}}   #=> insert into teams(name, `desc`, created_at, updated_at)
                            #   values ('sos', 'SOS Brigate', current_timestamp, current_timestap)
{{*p sos.id*}}   # id is set automatically
{{*q.insert(Member.new(nil, 'Haruhi', nil, sos.id, :current_timestamp, :current_timestamp))*}}
{{*q.insert(Member.new(nil, 'Mikuru', nil, sos.id, :current_timestamp, :current_timestamp))*}}
{{*q.insert(Member.new(nil, 'Yuki',   nil, sos.id, :current_timestamp, :current_timestamp))*}}

## insert Hash
ryouou = {:name=>'ryouou', :desc=>'Ryouou High-School',
          :created_at=>:current_timestamp, :updated_at=>:current_timestamp}
ryouou
{{*q.insert(Team, ryouou)*}}   #=> insert into teams(name, `desc`, created_at, updated_at)
                               #   values ('ryouou', 'Ryouou High-School', current_timestamp, current_timestamp)
id = q.last_insert_id
now = :current_timestamp
{{*q.insert(Member, {:name=>'Konata',  :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert(Member, {:name=>'Kagami',  :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert(Member, {:name=>'Tsukasa', :team_id=>id, :created_at=>now, :updated_at=>now})*}}
{{*q.insert(Member, {:name=>'Miyuki',  :team_id=>id, :created_at=>now, :updated_at=>now})*}}
#+++
require 'pp'
pp q.get_all(Team)
pp q.get_all(Member)
#---
.--------------------


.$$ select from

There are several methods for 'select from'.


.$$$ get()

Kwery::Query#get() returns a row.

.-------------------- 131_get1.rb
require 'kwery'
require 'kwery/adapters/mysql'
{{*require 'models'*}}
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## get model object
{{*sos = q.get(Team) {|c| c.where(:id, 1) }*}}
p sos     #=> #<Team @id=1, @name=>"sos", @desc="SOS Brigate", @leader_id=>nil, ... >
{{*haruhi = q.get(Member) {|c| c.where(:name, 'Haruhi') }*}}
p haruhi  #=> #<Team @id=1, @name="Haruhi", @desc=nil, @team_id=1, ... >
.--------------------

The followings are equivarent each other.

.* q.get(Member) { q.where(:name, 'Haruhi') }
.* q.get(Member) { q.where('name', 'Haruhi') }
.* q.get(Member) { q.where('name = ', 'Haruhi') }
.* q.get(Member) { q.where('name = %s', ['Haruhi']) }
.* q.get(Member) { q.where("name = 'Haruhi'") }

You can specify several 'where' conditions.

.-------------------- 132_get2.rb
t = Time.mktime(1990, 7, 7)
members = q.get(Member) {|c|
  {{*c.where(:team_id, sos.id).where('created_at >', t).where_is_not_null(:desc)*}}
}
### or
members = q.get(Member) {|c|
  c.where(:team_id, sos.id)
  c.where('created_at >', t)
  c.where_is_not_null(:desc)
}
.--------------------

{{,Query#get(ModelClass, {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#get(ModelClass) {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 133_get3.rb
### select row with condition
haruhi = q.get(Member, :name, 'Haruhi')
### This is equvarent to the following.
#haruhi = q.get(Member) {|c| c.where(:name, 'Haruhi') }
.--------------------


.$$$ get_all()

Kwery::Query#get() returns all rows matched to condition.

.-------------------- 141_get_all1.rb
require 'kwery'
require 'kwery/adapters/mysql'
{{*require 'models'*}}
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

## get all members of SOS Brigate
sos = q.get(Team) { q.where(:name, 'sos') }
{{*members = q.get_all(Member) { q.where(:team_id, sos.id) }*}}
for member in members
  p member  #=> #<Member @id=1, @name="Haruhi", @team_id=1, ... >
            #=> #<Member @id=2, @name="Mikuru", @team_id=1, ... >
	    #=> #<Member @id=3, @name="Yuki", @team_id=1, ... >
end
.--------------------

You can specify several 'where' conditions.

.-------------------- 142_get_all2.rb
t = Time.mktime(1990, 7, 7)
members = q.get_all(Member) {|c|
  {{*c.where(:team_id, sos.id]).where('created_at >', t).where_is_not_null(:desc)*}}
}
### or
members = q.get_all(Member) {|c|
  c.where(:team_id, sos.id])
  c.where('created_at >', t)
  c.where_is_not_null(:desc)
}
.--------------------

'order_by', 'group_by', 'having', 'limit' are also available.

.-------------------- 143_get_all3.rb
t = Time.mktime(1990, 7, 7)
members = q.get_all(Member) {|c|
  c.where(:team_id, sos.id){{*.order_by(:id).limit(0, 2)*}}
}
.--------------------

{{,Query#get_all(ModelClass, {{/arg1/}}, {{/arg2/}}),}} is equivarent to {{,Query#get_all(ModelClass) {|c| c.where({{/arg1/}}, {{/arg2/}}) },}}.

.-------------------- 144_get_all4.rb
members = {{*q.get_all(Member, :team_id, sos.id)*}}
### This is equivarent to the following
#members = q.get_all(Member) {|c| c.where(:team_id, sos.id) }
.--------------------


.$$$ select()

Kwery::Query#select() returns all rows matched to conditions.
It is able to specify select colums by Query#select().

.-------------------- 151_select_from1.rb
require 'kwery'
require 'kwery/adapters/mysql'
{{*require 'models'*}}
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### select only id and name columns
sos = q.get(Team) { q.where(:name, 'sos') }
{{*members = q.select(Member, 'id, name') { q.where(:team_id, sos.id) }*}}
p members    #=> [#<Member @name="Haruhi", @id=1>,
             #    #<Member @name="Mikuru", @id=2>,
             #    #<Member @name="Yuki", @id=3>]
.--------------------

It is able to specify class object as which records are get.

.-------------------- 152_select_form2.rb
.#+++
require 'setup'
q = $q
sos = q.get(Team) { q.where(:name, 'sos') }
.#---
### specify to get as Array instead of Hash
members = q.select(Member, 'id, name', {{*Array*}}) { q.where(:team_id, sos.id) }
p members   #=> [[1, 'Haruhi'], [2, 'Mikuru'], [3, 'Yuki']]
.--------------------

.#If you want to join tables, specify table names in select().
Currently it is not available to specify several model classes in select().

.-------------------- 153_select_from3.rb
.#+++
require 'setup'
q = $q
sos = q.get(Team) { q.where(:name, 'sos') }
.#---
## currently not available
records = q.select({{*[Member, Team]*}}, '*', Array) {
  {{*q.where('members.team_id = teams.id')*}}
}
.#require 'pp'
.#pp records  #=> [[1, "Haruhi", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
.#            #     1, "sos", "SOS Brigae", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [2, "Mikuru", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
.#            #     1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [3, "Yuki", nil, 1, #<Mysql::Time>, #<Mysql::Time>,
.#            #     1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [4, "Konata", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [5, "Kagami", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [6, "Tsukasa", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>],
.#            #    [7, "Miyuki", nil, 2, #<Mysql::Time>, #<Mysql::Time>,
.#            #     2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>]]
.--------------------

.#You can select only a certain table's record when joining.
.#
.#.-------------------- 154_select_from4.rb
.#records = q.select([Member, Team], {{*'members.*'*}}) {
.#  {{*q.where('members.team_id = teams.id').where('teams.name =', 'sos')*}}
.#}
.#p records  #=> [{"id"=>1, "name"=>"Haruhi", "team_id"=>1, ... },
.#           #    {"id"=>2, "name"=>"Mikuru", "team_id"=>1, ... },
.#           #    {"id"=>3, "name"=>"Yuki", "team_id"=>1, ... }]
.#.--------------------

.#Also left outer join is available.
Left outer join is available.

.-------------------- 155_select_from5.rb
.#+++
require 'setup'
q = $q
sos = q.get(Team) { q.where(:name, 'sos') }
.#---
records = q.select({{*Team*}}, '*', Array) {
  {{*q.left_outer_join(Member, 'leader_id')*}}
}
p records  #=> [[1, "sos", "SOS Brigate", nil, #<Mysql::Time>, #<Mysql::Time>,
           #    1, "Haruhi", nil, 1, #<Mysql::Time>, #<Mysql::Time>],
           #    [2, "ryouou", "Ryouou Hight-School", nil, #<Mysql::Time>, #<Mysql::Time>,
           #    nil, nil, nil, nil, nil, nil]]
.--------------------

The following is an example to count members for each teams.

.-------------------- 156_select_count6.rb
.#+++
require 'setup'
q = $q
.#---
records = q.select('teams, members', 'teams.id, count(*) count', Array) {|c|
  c.where('teams.id = members.team_id').group_by('teams.id').order_by('teams.id')
}
      #=> select teams.id, count(*) count from teams, members
      #   where teams.id = members.team_id
      #   group by teams.id
      #   order by teams.id

p records    #=> [[1, 3], [2, 4]]

records = q.select('teams t, members m', 't.id, t.name, count(*) count', Array) {|c|
  c.where('t.id = m.team_id').group_by('t.id, t.name').order_by('t.id')
}
      #=> select t.id, t.name, count(*) count from teams t, members m
      #   where t.id = m.team_id 
      #   group by t.id, t.name 
      #   order by t.id

p records    #=> [[1, "sos", 3], [2, "ryouou", 4]]
.--------------------


.$$ update

Query#update_model() updates an model object. It updates only a row and not able to specify any conditions.

Query#update() updates can update several rows matched to conditions.

.-------------------- 161_update1.rb
require 'kwery'
require 'kwery/adapters/mysql'
require 'models'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### update model object
### (only changed attributes are updated in sql.)
haruhi = q.get(Member) { q.where(:name, 'Haruhi') }
haruhi.desc = 'Leader of SOS Brigade'
{{*q.update_model(haruhi)*}}  #=> update members set `desc`='Leader of SOS Brigade' where id = 1
p q.get(Member, :id, haruhi.id) #=> #<Member @id=1, @name='Haruhi', @desc=>'Leader of SOS Brigade', ...>

### update rows
sos = q.get(Team) { q.where(:name, 'sos') }
{{*hash = {:leader_id=>haruhi.id, :updated_at=>:current_timestamp}*}}
{{*q.update(Team, hash) { q.where(:id, sos.id) }*}}
p q.select(Team, 'id, name, leader_id')
    #=> [#<Team @id=1, @name="sos", @leader_id=1>,
    #    #<Team @id=2, @name="ryouou", @leader_id=nil>]
.--------------------

You can specify condition arguments to Query#update().

.-------------------- 162_update2.rb
.#+++
require 'setup'
q = $q
sos = q.get(Team) { q.where(:name, 'sos') }
haruhi = q.get(Member) { q.where(:name, 'Haruhi') }
values = {:leader_id=>haruhi.id, :updated_at=>:current_timestamp}
.#---
### specify 'id' as condition
{{*q.update(Team, hash, :id, sos.id)*}}
### this is equivarent to the following
#q.update(Team, hash) { q.where(:id, sos.id) }
.#+++
require 'pp'
pp q.select(Team, 'id, name, leader_id')
.#---
.--------------------

You must specify conditions for Query#update(), or you'll get an error.
This is intended to avoid "accidential all update".

.-------------------- 164_update4_error.rb
.#+++
require 'setup'
q = $q
sos = q.get(Team) { q.where(:name, 'sos') }
haruhi = q.get(Member) { q.where(:name, 'Haruhi') }
values = {:leader_id=>haruhi.id, :updated_at=>:current_timestamp}
begin
.#---
### this will cause an error, because condition nor id is specified.
q.update(Team, values)    #=> Kwery::Error
.#+++
  puts "*** NG: Exception expected but not raised."
rescue Kwery::Error => ex
  require 'pp'
  pp ex
  puts "*** OK: Exception expected and raised correctly."
end
.#---
.--------------------

If you want to update all records, you must use Query#update_all() instead of update().

.-------------------- 165_update5.rb
### update all records in teams table
{{*q.update_all(Team, values)*}}   #=> update teams set ....
.--------------------


.$$ delete from

Query#delete_model() deletes a row of model data.

Query#delete() deletes rows matched to condition.

.-------------------- 171_delete_from1.rb
require 'kwery'
require 'kwery/adapters/mysql'
require 'models'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr     # reports SQL to $stderr

### delete model object
miyuki = q.get(Member) {|c| c.where(:name, 'Miyuki') }
q.delete_model(miyuki)    #=> delete from members where id = 7

### delete rows
ryouou = q.get(Team) { q.where(:name, 'ryouou') }
{{*q.delete(Member) { q.where(:team_id, ryouou.id) }*}}
                     #=> delete from members where team_id = 2
p q.select(Member)   #=> [#<Member @name="Haruhi", @team_id=1, ...>,
                     #    #<Member @name="Mikuru", @team_id=1, ...>,
                     #    #<Member @name="Yuki", @team_id=1, ...>]
.--------------------

It is able to specify condition arguments to Query#delete().

.-------------------- 172_delete_from2.rb
.#+++
require 'setup'
q = $q
.#---
### delete rows
ryouou = q.get(Team) { q.where(:name, 'ryouou') }
{{*q.delete(Member, :team_id, ryouou.id)*}}
### this is equivarent to the following
# q.delete(Member) { q.where(:team_id, ryouou.id) }
.#+++
p q.select(Member)
.#---
.--------------------

You need to specify any conditions, or you'll get an error.
This is intended to avoid "accidencall all deletion".

.-------------------- 173_delete_from3_error.rb
.#+++
require 'setup'
q = $q
begin
.#---
### this will raise error because no conditons nor no id is specified.
q.delete(Member)   #=> Kwery::Error
.#+++
  puts "*** NG: exception expected but not raised."
rescue Kwery::Error => ex
  p ex
  puts "*** OK: exception expected and raised."
end
.#---
.--------------------

If you want to delete all records, you must use delete_all() instead of delete().

.-------------------- 174_delete_from4.rb
### delete all records in members table
{{*q.delete_all(Member)*}}   #=> delete from members
.--------------------



.$ Relation


.$$ N : 1 (belongs to)

Kwery doesn't support relations(!).
Instead, some helper functions are provided.

Query#bind_references_to() is provided for 'belongs-to' relations.

Assume that the following tables.

.--------------------
mysql> select * from teams;  
+----+--------+--------------------+-----------+
| id | name   | desc               | leader_id |
+----+--------+--------------------+-----------+
|  1 | sos    | SOS Brigate        |         1 |
|  2 | ryouou | Ryouou High-School |         4 |
+----+--------+--------------------+-----------+

mysql> select * from members;
+----+---------+---------+
| id | name    | team_id |
+----+---------+---------+
|  1 | Haruhi  |       1 | 
|  2 | Mikuru  |       1 | 
|  3 | Yuki    |       1 | 
|  4 | Konata  |       2 | 
|  5 | Kagami  |       2 | 
|  6 | Tsukasa |       2 | 
|  7 | Miyuki  |       2 | 
+----+---------+---------+
.--------------------

In this case, you can avoid '1+N' problem by Query#bind_references_to().

.% bind_references_to(items, table, column, attr, not_null=true)
	.[items]	array of hash, or array of model objects
	.[table]	table name string, or model class.
	.[column]	foreign key name (string)
	.[attr]		attribute name (string or symbol)
	.[no_tull]	set false if foreign key is nullable.

.? ex301.rb
.-------------------- ex301.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all members
members = q.get_all('members') {|c| c.order_by(:id) }
    #=> select * from members order by id

## set related team to each member
## (model class object is available as table name)
{{*q.bind_references_to(members, 'teams', 'team_id', 'team')*}}
    #=> select * from teams where id in (1,1,1,2,2,2,2)

## show members
.#require 'pp'
.#pp members
for m in members
  team = m['team']
  puts "%2d, %7s, %2d, %7s" % [m['id'], m['name'], team['id'], team['name']]
end
.--------------------

.? result
.====================
$ ruby ex301.rb
 1,  Haruhi,  1,     sos
 2,  Mikuru,  1,     sos
 3,    Yuki,  1,     sos
 4,  Konata,  2,  ryouou
 5,  Kagami,  2,  ryouou
 6, Tsukasa,  2,  ryouou
 7,  Miyuki,  2,  ryouou
.====================

Query#bind_references_to() avoids '1+N' problem by {{,where-in,}} condition.


.$$ 1 : N (has many)

Query#bind_referenced_from() is a reverse of bind_references_to().

.% bind_references_to(items, table, column, attr, not_null=true, multiple=true)
	.[items]	array of hash, or array of model objects
	.[table]	table name string, or model class.
	.[column]	foreign key name (string)
	.[attr]		attribute name (string or symbol)
	.[not_null]	set false if foreign key is nullable.
	.[multiple]	set false when has-one relation.


.? ex302.rb
.-------------------- ex302.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all teams
teams = q.get_all('teams') {|c| c.order_by(:id) }
    #=> select * from teams order by id

## set related members to each team
## (model class object is available as table name)
{{*q.bind_referenced_from(teams, 'members', 'team_id', 'all_members')*}}
    #=> select * from members where team_id in (1,2)

## inspect members
require 'pp'
pp teams
.#
.### show all members for each team
.#for team in teams
.#  puts   "team: %s" % team['name']
.#  puts   "members:\n"
.#  for member in team['all_members']
.#    puts "  - {id: %d, name: %s}" % [member['id'], member['name']]
.#  end
.#end
.--------------------

.? result (modified for readability)
.====================
$ ruby ex302.rb
[
  {
    "id"   => 1,
    "name" => "sos",
    "desc" => "SOS Brigate",
    "leader_id" => 1,
    "all_members" => [
      {"id"=>1, "team_id"=>1, "name"=>"Haruhi"},
      {"id"=>2, "team_id"=>1, "name"=>"Mikuru"},
      {"id"=>3, "team_id"=>1, "name"=>"Yuki"  },
    ],
  },
  {
    "id"   => 2,
    "name" => "ryouou",
    "desc" => "Ryouou High-School",
    "leader_id" => 4,
    "all_members" => [
      {"id"=>4, "team_id"=>2, "name"=>"Konata" },
      {"id"=>5, "team_id"=>2, "name"=>"Kagami" },
      {"id"=>6, "team_id"=>2, "name"=>"Tsukasa"},
      {"id"=>7, "team_id"=>2, "name"=>"Miyuki" },
    ],
  },
]
.====================


.$$ 1 : 1 (has one)

Query#bind_referenced_from() can handle has-one relation.

.? ex303.rb
.-------------------- ex303.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
#q.output = $stderr

## get all members
members = q.get_all('members') {|c| c.order_by(:id) }
    #=> select * from members order by id

## set related teams which each member owns.
## (model class object is available as table name)
{{*q.bind_referenced_from(members, 'teams', 'leader_id', 'lead', false, false)*}}
    #=> select * from teams where leader_id in (1,2,3,4,5,6,7)

## inspect members
require 'pp'
pp members
.--------------------

.? result (only Haruhi and Konata have their own team)
.====================
# ruby ex303.rb
[{"team_id"=>1,
  "name"=>"Haruhi",
  "id"=>1,
  "lead"=>{"name"=>"sos", "id"=>1, "desc"=>"SOS Brigate", "leader_id"=>1}},
 {"team_id"=>1, "name"=>"Mikuru", "id"=>2, "lead"=>nil},
 {"team_id"=>1, "name"=>"Yuki", "id"=>3, "lead"=>nil},
 {"team_id"=>2,
  "name"=>"Konata",
  "id"=>4,
  "lead"=>
   {"name"=>"ryouou", "id"=>2, "desc"=>"Ryouou High-School", "leader_id"=>4}},
 {"team_id"=>2, "name"=>"Kagami", "id"=>5, "lead"=>nil},
 {"team_id"=>2, "name"=>"Tsukasa", "id"=>6, "lead"=>nil},
 {"team_id"=>2, "name"=>"Miyuki", "id"=>7, "lead"=>nil}]
.====================


.$$ N : M (has many through)

Query#select() can handle N : M relation.

For example, assume the folloing tables.

.--------------------
create_table tags (
  id       integer        primary key auto_increment,
  name     varchar(255)   not null unique
);

create table posts (
  id       integer        primary key auto_increment,
  title    varchar(255)   not null,
  content  text           not null
);

create table taggings (
  id       integer        primary key auto_increment,
  tag_id   integer        not null references tags(id),
  post_id  integer        not null references posts(id)
);
.--------------------

The following is an example to handle N : M relation by Query#select().

.? ex304.rb : select all posts which are tagged as 'anime'
.-------------------- ex304.rb
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr

## without model class
posts = q.select({{*'posts, tags, taggings'*}}, 'posts.*') {|c|
  {{*c.where('tags.id = taggings.tag_id')*}}
  {{*c.where('posts.id = taggings.post_id')*}}
  c.where('tags.name', 'anime')
}
      #=> select posts.* from posts, tags, taggings
      #   where tags.id = taggings.tag_id
      #     and posts.id = taggings.post_id
      #     and tags.name = 'anime'
.--------------------


.$ Others


.$$ Corresponding SQL


Methods of Kwery::Query class:

.? Methods of Kwery::Query class
.+--------------------
Methods of Kwery::Query class			., Corresponding SQL
.--------------------
get({{/table/}})				., select * from {{/table/}}
get_all({{/table/}})			., select * from {{/table/}}
select({{/table/}}, {{/columns/}})	., select {{/columns/}} from {{/table/}}
insert({{/table/}}, {{/values/}})		., insert into {{/table/}} values {{/values/}}
update({{/table/}}, {{/values/}})		., update {{/table/}} set {{/values/}}
update_all({{/table/}}, {{/values/}})	., update {{/table/}} set {{/values/}}
delete({{/table/}})     			., delete from {{/table/}}
delete_all({{/table/}})			., delete from {{/table/}}
execute({{/sql/}})			., -
with()					., -
with!()					., -
.+--------------------


Methods of Kwery::QueryContext class:

.? Methods of Kwery::QueryContext class
.+--------------------
Methods of Kwery::QueryContext class		., Corresponding SQL
.--------------------
where({{/column/}}, {{/value/}})		., where {{/column/}} = {{/value/}}
or_where({{/column/}}, {{/value/}})		., ... or where {{/column/}} = {{/value/}}
or_where!({{/column/}}, {{/value/}})		., (...) or where {{/column/}} = {{/value/}}
and_where({{/column/}}, {{/value/}})		., ... and where {{/column/}} = {{/value/}}
and_where!({{/column/}}, {{/value/}})		., (...) and where {{/column/}} = {{/value/}}
where_in({{/column/}}, {{/array/}})		., where {{/column/}} in {{/elem1,elem2,.../}}
where_between({{/column/}}, {{/val1/}}, {{/val2/}})	., where {{/column/}} between {{/val1/}} and {{/val2/}}
where_is_null({{/column/}})			., where {{/column/}} is null
where_is_not_null({{/column/}})			., where {{/column/}} is not null
group_by({{/columns/}})				., group by {{/columns/}}
order_by({{/columns/}})				., order by {{/columns/}}
order_by_desc({{/columns/}})			., order by {{/columns/}} desc
having({{/column/}}, {{/value/}})		., having {{/column/}} = {{/value/}}
limit({{/offset/}}, {{/count/}})		., limit {{/offset/}}, {{/count/}}
join({{/join_table/}}, {{/column/}}, {{/pkey/}})	., join {{/join_table/}} on {{/table/}}.{{/column/}} = {{/join_table/}}.{{/pkey/}}
left_outer_join({{/join_table/}}, {{/column/}}, {{/pkey/}})	., left_outer_join {{/join_table/}} on {{/table/}}.{{/column/}} = {{/join_table/}}.{{/pkey/}}
left_inner_join({{/join_table/}}, {{/column/}}, {{/pkey/}})	., left_inner_join {{/join_table/}} on {{/table/}}.{{/column/}} = {{/join_table/}}.{{/pkey/}}
right_outer_join({{/join_table/}}, {{/column/}}, {{/pkey/}})	., right_outer_join {{/join_table/}} on {{/table/}}.{{/column/}} = {{/join_table/}}.{{/pkey/}}
right_inner_join({{/join_table/}}, {{/column/}}, {{/pkey/}})	., right_inner_join {{/join_table/}} on {{/table/}}.{{/column/}} = {{/join_table/}}.{{/pkey/}}
.+--------------------


.$$ Table name alias in SQL

It is specify table name alias in SQL.

.-------------------- ex401_alias.rb
.#+++
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr
.#---
## without model class
posts = q.select({{*'posts p, tags t, taggings g'*}}, 'p.*') {|c|
  {{*c.where('t.id = g.tag_id').where('p.id = g.post_id')*}}.where('t.name', 'anime')
}
      #=> select posts.* from posts p, tags, taggings
      #   where t.id = g.tag_id and p.id = g.post_id and t.name = 'anime'

## with model class
class Post
  include Kwery::Model
  set_table_name('posts')
end
class Tag
  include Kwery::Model
  set_table_name('tags')
end
class Tagging
  include Kwery::Model
  set_table_name('taggings')
end

posts = q.select({{*{'p'=>Post, 't'=>Tag, 'g'=>Tagging}*}}, 'p.*') {|c|
  {{*c.where('t.id = g.tag_id').where('p.id = g.post_id')*}}.where('t.name', 'anime')
}
      #=> select p.* from posts p, tags t, taggings g
      #   where t.id = g.tag_id and p.id = g.post_id and t.name = 'anime'
.--------------------


.$$ Query#with()

Query#with() is a solution to set conditions before select/update/delete.

.-------------------- ex402_with.rb
.#+++
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr
.#---
## set conditions before select
t = Time.mktime(2000, 1, 1)
members = q.{{*with() {|c|*}}
  {{*c.where('created_at >=', t).order_by(:id)*}}
{{*}*}}.get_all('members') {|c|
  c.where('team_id', 1)
}
   #=> select * from members
   #   where created_at > '2000-01-01 00:00:00' and team_id = 1
   #   order by id

## or
members = q.{{*with('created_at >=', t) {|c| c.order_by(:id) }*}}.get_all('members', :team_id, 1)
   #=> select * from members
   #   where created_at > '2000-01-01 00:00:00' and team_id = 1
   #   order by id
.--------------------

Query#with() returns a new Query object, so you can save it to variable.

.-------------------- ex403_with.rb
.#+++
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr
.#---
## save new Query object which q.with() returns
t = Time.mktime(2000, 1, 1)
q2 = q.with() {|c| c.where('created_at >=', t).order_by(:id) }
members = q2.get_all('members', :team_id, 1)
   #=> select * from members
   #   where created_at > '2000-01-01 00:00:00' and team_id = 1
   #   order by id
teams = q2.get_all('teams') {|c| c.where_is_not_null(:leader_id) }
   #=> select * from teams
   #   where created_at > '2000-01-01 00:00:00' and leader_id is not null
   #   order by id
.--------------------


.$$ Named scope

If you love named_scope of ActiveRecord, define helper methods in Query class using Query#with().

.-------------------- ex404_with.rb
.#+++
require 'kwery'
require 'kwery/adapters/mysql'
conn = Kwery.connect('localhost', 'username', 'password', 'dbname')
q = Kwery::Query.new(conn)
q.output = $stderr
.#---
## define helper methods
module MyCondition
  def newer_than(time)
    return self.with() {|c| c.where('created_at >=', time).order_by(:id) }
  end
end
class Kwery::Query
  include MyCondition
end

## usage
t = Time.mktime(2000, 1, 1)
members = q.newer_than(t).get_all('members', :team_id, 1)
   #=> select * from members
   #   where created_at > '2000-01-01 00:00:00' and team_id = 1
   #   order by id
.--------------------
